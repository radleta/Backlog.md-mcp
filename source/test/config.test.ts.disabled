import { describe, test, expect, beforeEach, afterEach, mock, spyOn } from 'bun:test';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import {
	getClaudeConfigPath,
	readClaudeConfig,
	writeClaudeConfig,
	getLocalConfig,
	saveLocalConfig,
	get,
	set,
	getBacklogCliPath
} from '../src/config';
import { MockFileSystem, mockPlatform, mockEnv } from './utils/mocks';
import { claudeConfigs, platformPaths } from './utils/fixtures';

describe('Configuration Management', () => {
	let mockFS: MockFileSystem;
	let restorePlatform: () => void;
	
	beforeEach(() => {
		mockFS = new MockFileSystem();
	});
	
	afterEach(() => {
		if (restorePlatform) {
			restorePlatform();
		}
	});
	
	describe('getClaudeConfigPath', () => {
		test('should return correct path for macOS', async () => {
			restorePlatform = mockPlatform('darwin');
			
			// Mock fs.access to succeed
			const accessSpy = spyOn(fs, 'access').mockResolvedValue(undefined);
			
			const configPath = await getClaudeConfigPath();
			expect(configPath).toContain('Library/Application Support/Claude');
			expect(configPath).toContain('claude_desktop_config.json');
			
			accessSpy.mockRestore();
		});
		
		test('should return correct path for Windows', async () => {
			restorePlatform = mockPlatform('win32');
			const restoreEnv = mockEnv({ APPDATA: 'C:\\Users\\Test\\AppData\\Roaming' });
			
			const accessSpy = spyOn(fs, 'access').mockResolvedValue(undefined);
			
			const configPath = await getClaudeConfigPath();
			expect(configPath).toContain('Claude');
			expect(configPath).toContain('claude_desktop_config.json');
			expect(configPath).toContain('AppData');
			
			accessSpy.mockRestore();
			restoreEnv();
		});
		
		test('should return correct path for Linux', async () => {
			restorePlatform = mockPlatform('linux');
			
			const accessSpy = spyOn(fs, 'access').mockResolvedValue(undefined);
			
			const configPath = await getClaudeConfigPath();
			expect(configPath).toContain('.config/claude');
			expect(configPath).toContain('claude_desktop_config.json');
			
			accessSpy.mockRestore();
		});
		
		test('should create config file if it does not exist', async () => {
			restorePlatform = mockPlatform('darwin');
			
			const accessSpy = spyOn(fs, 'access').mockRejectedValue(new Error('ENOENT'));
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			const configPath = await getClaudeConfigPath();
			
			expect(configPath).toBeTruthy();
			expect(mkdirSpy).toHaveBeenCalled();
			expect(writeFileSpy).toHaveBeenCalledWith(
				expect.stringContaining('claude_desktop_config.json'),
				JSON.stringify({ mcpServers: {} }, null, 2)
			);
			
			accessSpy.mockRestore();
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
		
		test('should return null for unsupported platform', async () => {
			// Mock an unsupported platform
			Object.defineProperty(process, 'platform', {
				value: 'unsupported',
				configurable: true
			});
			
			const configPath = await getClaudeConfigPath();
			expect(configPath).toBeNull();
			
			// Restore
			Object.defineProperty(process, 'platform', {
				value: 'darwin',
				configurable: true
			});
		});
	});
	
	describe('readClaudeConfig', () => {
		test('should read and parse config file', async () => {
			const configData = JSON.stringify(claudeConfigs.configured, null, 2);
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue(configData);
			
			const config = await readClaudeConfig('/path/to/config.json');
			
			expect(config).toEqual(claudeConfigs.configured);
			expect(readFileSpy).toHaveBeenCalledWith('/path/to/config.json', 'utf-8');
			
			readFileSpy.mockRestore();
		});
		
		test('should return null if file does not exist', async () => {
			const error: any = new Error('File not found');
			error.code = 'ENOENT';
			const readFileSpy = spyOn(fs, 'readFile').mockRejectedValue(error);
			
			const config = await readClaudeConfig('/nonexistent/config.json');
			
			expect(config).toBeNull();
			
			readFileSpy.mockRestore();
		});
		
		test('should throw error for other read failures', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockRejectedValue(new Error('Permission denied'));
			
			expect(readClaudeConfig('/path/to/config.json')).rejects.toThrow('Permission denied');
			
			readFileSpy.mockRestore();
		});
		
		test('should handle malformed JSON', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue('{ invalid json }');
			
			expect(readClaudeConfig('/path/to/config.json')).rejects.toThrow();
			
			readFileSpy.mockRestore();
		});
	});
	
	describe('writeClaudeConfig', () => {
		test('should write config file with proper formatting', async () => {
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			await writeClaudeConfig('/path/to/config.json', claudeConfigs.configured);
			
			expect(mkdirSpy).toHaveBeenCalledWith('/path/to', { recursive: true });
			expect(writeFileSpy).toHaveBeenCalledWith(
				'/path/to/config.json',
				JSON.stringify(claudeConfigs.configured, null, 2)
			);
			
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
		
		test('should create directory if it does not exist', async () => {
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			await writeClaudeConfig('/new/path/config.json', {});
			
			expect(mkdirSpy).toHaveBeenCalledWith('/new/path', { recursive: true });
			
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
	});
	
	describe('Local Configuration', () => {
		const localConfigPath = path.join(os.homedir(), '.backlog-mcp', 'config.json');
		
		test('should get local config value', async () => {
			const config = { backlogCliPath: '/usr/local/bin/backlog' };
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue(JSON.stringify(config));
			
			const value = await get('backlogCliPath');
			
			expect(value).toBe('/usr/local/bin/backlog');
			expect(readFileSpy).toHaveBeenCalledWith(localConfigPath, 'utf-8');
			
			readFileSpy.mockRestore();
		});
		
		test('should set local config value', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue('{}');
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			await set('transport', 'http');
			
			expect(writeFileSpy).toHaveBeenCalledWith(
				localConfigPath,
				JSON.stringify({ transport: 'http' }, null, 2)
			);
			
			readFileSpy.mockRestore();
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
		
		test('should return empty object if local config does not exist', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockRejectedValue(new Error('ENOENT'));
			
			const config = await getLocalConfig();
			
			expect(config).toEqual({});
			
			readFileSpy.mockRestore();
		});
		
		test('should save local config with proper formatting', async () => {
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			const config = { key1: 'value1', key2: 'value2' };
			await saveLocalConfig(config);
			
			expect(mkdirSpy).toHaveBeenCalled();
			expect(writeFileSpy).toHaveBeenCalledWith(
				localConfigPath,
				JSON.stringify(config, null, 2)
			);
			
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
	});
	
	describe('getBacklogCliPath', () => {
		test('should return custom path if configured', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue(
				JSON.stringify({ backlogCliPath: '/custom/path/backlog' })
			);
			
			const cliPath = await getBacklogCliPath();
			
			expect(cliPath).toBe('/custom/path/backlog');
			
			readFileSpy.mockRestore();
		});
		
		test('should return bundled path if available', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue('{}');
			const accessSpy = spyOn(fs, 'access').mockResolvedValue(undefined);
			
			const cliPath = await getBacklogCliPath();
			
			expect(cliPath).toContain('node_modules/.bin/backlog');
			
			readFileSpy.mockRestore();
			accessSpy.mockRestore();
		});
		
		test('should fallback to global backlog command', async () => {
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue('{}');
			const accessSpy = spyOn(fs, 'access').mockRejectedValue(new Error('Not found'));
			
			const cliPath = await getBacklogCliPath();
			
			expect(cliPath).toBe('backlog');
			
			readFileSpy.mockRestore();
			accessSpy.mockRestore();
		});
	});
	
	describe('Configuration Merging', () => {
		test('should merge new config with existing', async () => {
			const existing = { mcpServers: { 'other-server': {} } };
			const readFileSpy = spyOn(fs, 'readFile').mockResolvedValue(JSON.stringify(existing));
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			const writeFileSpy = spyOn(fs, 'writeFile').mockResolvedValue(undefined);
			
			const newConfig = {
				...existing,
				mcpServers: {
					...existing.mcpServers,
					'backlog-md': { command: 'backlog-mcp' }
				}
			};
			
			await writeClaudeConfig('/path/to/config.json', newConfig);
			
			const writtenConfig = JSON.parse(writeFileSpy.mock.calls[0][1] as string);
			expect(writtenConfig.mcpServers).toHaveProperty('other-server');
			expect(writtenConfig.mcpServers).toHaveProperty('backlog-md');
			
			readFileSpy.mockRestore();
			mkdirSpy.mockRestore();
			writeFileSpy.mockRestore();
		});
	});
	
	describe('Error Handling', () => {
		test('should handle permission errors gracefully', async () => {
			const error: any = new Error('Permission denied');
			error.code = 'EACCES';
			const writeFileSpy = spyOn(fs, 'writeFile').mockRejectedValue(error);
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			
			expect(writeClaudeConfig('/protected/config.json', {})).rejects.toThrow('Permission denied');
			
			writeFileSpy.mockRestore();
			mkdirSpy.mockRestore();
		});
		
		test('should handle disk full errors', async () => {
			const error: any = new Error('No space left on device');
			error.code = 'ENOSPC';
			const writeFileSpy = spyOn(fs, 'writeFile').mockRejectedValue(error);
			const mkdirSpy = spyOn(fs, 'mkdir').mockResolvedValue(undefined);
			
			expect(writeClaudeConfig('/path/config.json', {})).rejects.toThrow('No space left on device');
			
			writeFileSpy.mockRestore();
			mkdirSpy.mockRestore();
		});
	});
});